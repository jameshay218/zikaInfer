#' Simulates head circumference data from an SEIR vector borne model
#'
#' Takes a list of necessary arguments to solve a system of ODEs that generates head circumferences of new born infants
#' @param allPars A list of parameter vectors. First vector should be an array of time points over which to solve the SEIR model. Second vector should be the vector of starting conditions. Third vector should be all of the parameters.
#' @return a matrix of simulated head circumferences over time.
#' @export
#' @useDynLib zikaProj
zika.sim <- function(allPars,headMeasurements=TRUE,buckets=NULL){
    ## Get length and time step for ODE solver
    y <- solveModel(allPars)
    y <- as.data.frame(y)
    y0s <- allPars[[2]]
    pars <- allPars[[3]]
    
    sampFreq <- pars["sampFreq"]
    sampPropn <- pars["sampPropn"]
    mu_I <- pars["mu_I"]
    sd_I <- pars["sd_I"]
    mu_N <- pars["mu_N"]
    sd_N <- pars["sd_N"]
    probMicro <- pars["probMicro"]
    baselineProb <- pars["baselineProb"]
    lifeExpectancy <- pars["L_H"]
 
    daysPerYear <- nrow(y)/max(y$times)
    birthsPerYear <- sum(y0s[4:6])/lifeExpectancy
    birthsPerDay <- ceiling(birthsPerYear/daysPerYear)
    if(headMeasurements){
        if(!is.null(buckets)){
            alphas_I<- calculate_alphas_buckets(as.matrix(unname(y[,c("times","I_F","S_F","E_F","R_F")])),probMicro,buckets)
        }
        else {
            alphas_I<- calculate_alphas(as.matrix(unname(y[,c("I_F","S_F","E_F","R_F")])),probMicro,sampFreq)
        }
        alphas_N <- 1 - alphas_I
    }
    else {
        if(!is.null(buckets)){
            alphas_I <- calculate_alphas_prob_buckets(as.matrix(unname(y[,c("times","I_F","S_F","E_F","R_F")])),probMicro, baselineProb, buckets)
        }
        else {
            alphas_I <- calculate_alphas_prob_sampfreq(as.matrix(unname(y[,c("I_F","S_F","E_F","R_F")])),probMicro, baselineProb, sampFreq)
        }
    }
    N <- sampPropn*birthsPerDay*sampFreq
    index <- 1
    all <- NULL
    while(index <= length(alphas_I)){
        if(!is.null(buckets)) N <- sampPropn*(birthsPerYear*(buckets[index,"end"]-buckets[index,"start"]))
        else N <- sampPropn*(birthsPerDay*sampFreq)

        if(headMeasurements){
            components <- sample(1:2,c(alphas_I[index],alphas_N[index]),size=N,replace=TRUE)
            mus <- c(mu_I,mu_N)
            sds <- c(sd_I,sd_N)
            
            distribution <- round(rnorm(n=N,mean=mus[components],sd=sds[components]),digits=1)
            all[[index]] <- distribution
        }
        else all[[index]] <- rbind(ceiling(alphas_I[index]*N), ceiling(N-(alphas_I[index]*N)))
        index <- index + 1
    }
    tmp <- as.matrix(rbind.fill(lapply(all,function(x) {as.data.frame(t(x))})))
    if(!headMeasurements | !is.null(buckets)) colnames(tmp) <- c("microCeph","births")
    return(tmp)
}

#' Solve ODE model
#'
#' Given a list of parameters as generated by \code{\link{setupListPars}}, solves the ODE model and returns a named data frame that can be passed to \code{\link{plot_dynamics}}
#' @param allPars the list of parameters needed for the ODE model
#' @return a data frame of the solved ODE model
#' @export
#' @seealso \code{\link{solveModelSimple}}
solveModel <- function(allPars){
    ## First set of pars is time parameters
    t_pars <- allPars[[1]]
    ## Run time of model
    time_length <- t_pars[1]
    ## Step size
    time_by <- t_pars[2]

    ## Second set of pars is starting population sizes
    y0s <- allPars[[2]]

    ## Third set of pars is model parameters
    pars <- allPars[[3]]

    ## Burn in and delayed epidemic start
    burnin <- pars["burnin"]
    epiStart <- pars["epiStart"]

    ## Package ODE pars
    pars <- pars[c("L_M","D_EM","L_H","D_C","D_F","D_EH","D_IH","b","p_HM","p_MH","constSeed")]

    ## Temporarily remove initial seeding  for burn in period
    I0 <- y0s["I_A"]
    y0s[11] <- 0
    y0s[5] <- y0s["S_A"] + I0

    ## Create time series for ode solver
    if(burnin+epiStart > time_by){
        ts1 <- seq(0, burnin+epiStart,by=time_by)
        y1 <- ode(y0s,ts1,func="derivs",parms=pars,dllname="zikaProj",initfunc="initmod",hmax=1e-4,nout=0)
        if(is.null(y1) || nrow(y1) < 1) return("Error")
        
        colnames(y1) <- c("times","S_M","E_M","I_M","S_C","S_A","S_F","E_C","E_A","E_F","I_C","I_A","I_F","R_C","R_A","R_F")
        y0s2 <- y1[nrow(y1),2:ncol(y1)]
        y1[,"times"] <- y1[,"times"] - burnin
        y1 <- y1[y1[,"times"] >= 0,]
       
    } else {
        y0s2 <- y0s
    }

    ## Restore I0 to positive value
    y0s2["I_A"] <- I0
    y0s2["S_A"] <- y0s2["S_A"] - I0
    
    ts2 <- seq(epiStart, time_length,by=time_by)
    y <- ode(y0s2,ts2,func="derivs",parms=pars,dllname="zikaProj",initfunc="initmod",hmax=1e-4,nout=0)
    if(is.null(y)) return("Error")
    
    if(epiStart > 0){
        y <- rbind(y1,y)
    }
    
    #y <- as.data.frame(y)
    colnames(y) <- c("times","S_M","E_M","I_M","S_C","S_A","S_F","E_C","E_A","E_F","I_C","I_A","I_F","R_C","R_A","R_F")
    return(y)
    
}



#' R0 calculation
#'
#' Calculates the R0 of the SEIR model given a vector of parameters and human/mosquito population sizes. R0 defined as number of expected human cases given introduction of 1 infected human into a totally naive population of humans and mosquitoes.
#' @param params Vector of parameters matching those returned by \code{\link{setupListPars}}
#' @param NH integer value for human population size
#' @param NM integer value for mosquito population size
#' @return A single value for R0
#' @export
#' @seealso \code{\link{b.calc}}
r0.calc <- function(params,NH,NM){
    muM <- 1/params["L_M"]
    sigmaM <- 1/params["D_EM"]

    muH <- 1/params["L_H"]
    gammaH <- 1/params["D_IH"]

    b <- params["b"]
    pHM <- params["p_HM"]
    pMH <- params["p_MH"]
    
        
    #'    first <- (b * pHM * NM)/((gammaH + muH)*NH)
    #'  second <- (sigmaM/(sigmaM+muM))*(b * pMH )/muM

    #' R0 <- first*second
    R0 <- (b^2*pHM*pMH*NM*sigmaM)/((sigmaM+muM)*muM*(gammaH+muH)*NH)
    return(unname(R0))
}

#' Bite rate calculation
#'
#' Calculates the bite rate needed to generate a given R0 value, assuming that all other parameters are fixed.
#' @param params Vector of parameters matching those returned by \code{\link{setupListPars}}
#' @param NH integer value for human population size
#' @param NM integer value for mosquito population size
#' @param R0 desired R0 value
#' @return A single value for bite rate
#' @export
#' @seealso \code{\link{r0.calc}}
b.calc <- function(params,NH,NM,R0){
    muM <- 1/params["L_M"]
    sigmaM <- 1/params["D_EM"]

    muH <- 1/params["L_H"]
    gammaH <- 1/params["D_IH"]

    b <- params["b"]
    pHM <- params["p_HM"]
    pMH <- params["p_MH"]
  
    b <- sqrt(((sigmaM+muM)*muM*(gammaH+muH)*NH)/((pHM * pMH * NM * sigmaM))*R0)
    return(unname(b))
    
}

#' Generate microceph curve
#'
#' Generates the microcephaly risk curve from model parameters
#' @param pars the model parameters
#' @return a vector of risks
#' @export
#' @useDynLib zikaProj
generate_micro_curve <- function(pars){
    
    gammaMean <- pars["mean"]
    gammaVar <- pars["var"]
    
    rate <- gammaMean/gammaVar
    shape <- gammaMean*rate
    
    probs <- dgamma(0:39,shape,rate)*pars["scale"]
    probs[probs > 1] <- 1
    probs <- rep(probs, each=pars["tstep"])
    return(probs)
}

#' Solve simple SEIR model 
#'
#' Given a list of parameters as generated by \code{\link{setupListPars}}, solves the simple SEIR model and returns a named data frame
#' @param allPars the list of parameters needed for the ODE model
#' @return a data frame of the solved ODE model
#' @export
#' @seealso \code{\link{solveModel}}
solveModelSimple <- function(allPars){
  ## First set of pars is time parameters
  t_pars <- allPars[[1]]
  ## Run time of model
  time_length <- t_pars[1]
  ## Step size
  time_by <- t_pars[2]
  ## Second set of pars is starting population sizes
  y0s <- allPars[[2]]
  
  ## Third set of pars is model parameters
  pars <- allPars[[3]]
  
  ## Burn in and delayed epidemic start
  burnin <- pars["burnin"]
  epiStart <- pars["epiStart"]
  
  ## Package ODE pars
  pars <- pars[c("L_M","L_H","D_EM","D_EH","D_IH","b","p_HM","p_MH","constSeed")]
  ## Temporarily remove initial seeding  for burn in period
  I0 <- y0s["I_H"]
  y0s["I_H"] <- 0
  y0s["S_H"] <- y0s["S_H"] + I0
  
  ## Create time series for ode solver
  if(burnin+epiStart > time_by){
    ts1 <- seq(0, burnin+epiStart,by=time_by)
    y1 <- ode(y0s,ts1,func="simpleSEIR",parms=pars,dllname="zikaProj",initfunc="initmodSEIR",nout=0)
    if(is.null(y1) || nrow(y1) < 1) return("Error")
    
    colnames(y1) <- c("times","S_M","E_M","I_M","S_H","E_H","I_H","R_H")
    y0s2 <- y1[nrow(y1),2:ncol(y1)]
    y1[,"times"] <- y1[,"times"] - burnin
    y1 <- y1[y1[,"times"] >= 0,]
    
  } else {
    y0s2 <- y0s
  }
  
  ## Restore I0 to positive value
  y0s2["I_H"] <- I0
  y0s2["S_H"] <- y0s2["S_H"] - I0
  
  ts2 <- seq(epiStart, time_length,by=time_by)
 
  y <- ode(y0s2,ts2,func="simpleSEIR",parms=pars,dllname="zikaProj",initfunc="initmodSEIR",nout=0)
  if(is.null(y)) return("Error")
  if(epiStart > 0){
    y <- rbind(y1,y)
  }
  colnames(y) <- c("times","S_M","E_M","I_M","S_H","E_H","I_H","R_H")
  return(y)
}

#' Get days per month of the year
#'
#' Returns a vector of days per month
#' @return vector of days
#' @export
#' @useDynLib zikaProj
getDaysPerMonth <- function(){
    days <- c(31,28,31,30,31,30,31,31,30,31,30,31)
    return(days)
}

#' Solve simple SEIR model 
#'
#' Given a list of parameters as generated by \code{\link{setupListPars}}, solves the simple SEIR model and returns a named data frame
#' @param allPars the list of parameters needed for the ODE model
#' @return a data frame of the solved ODE model
#' @export
generate_microceph_dat <- function(t_pars, y0s, pars, births, weeks=FALSE){
    length <- t_pars["dur"]/365

    if(!weeks) buckets <- rep(getDaysPerMonth(),length)
    else buckets <- rep(7, 365/7 * length)

    N_H <- sum(y0s[c("S_H","E_H","I_H","R_H")])
    y <- solveModelSimple(list(t_pars,y0s,pars))
    ## Generate weekly microcephaly probabilities

    gammaMean <- pars["mean"]
    gammaVar <- pars["var"]
    
    rate <- gammaMean/gammaVar
    shape <- gammaMean*rate
    #probs <- dgamma(0:39, pars["shape"],pars["rate"])*pars["scale"]
    
    probs <- dgamma(0:39,shape,rate)*pars["scale"]

    #probs <- c(rep(pars["shape"],13),rep(pars["rate"],13),rep(pars["scale"],14))
    probs[probs > 1] <- 1
    
    ## Repeat each week so that we have risk for each day
    probs <- rep(probs, each=7)
    
    probM <- generate_probM(y[,"I_M"],probs, N_H, pars["b"], pars["p_MH"], pars["baselineProb"], 1)

    probM <- average_buckets(probM, buckets)
    
    microDat <- as.integer(probM*births)
    allDat <- cbind("startDay" = cumsum(buckets)-buckets,"endDay" =cumsum(buckets),"buckets"=buckets,"microCeph"=microDat,"births"=rep(births,length(buckets)))
    
    return(allDat)
}

    

#' Defaults ODE parameters
#'
#' Generates the default vector of parameters for the ODE model. Can specify which version of the model to use. Passing 1 gives the simple model with no age classes, otherwise gives the parameters for the model with age classes.
#' @return vector of named parameter values
#' @export
#' @useDynLib zikaProj
setupParsODE <- function(version=1){
    D_EM=10.5
    D_EH=4
    D_IH=5
    L_M=14
    L=73.6*365
    D_C=18 * 365
    D_F=3/12 *365
    b=100/365
    p_MH=0.5
    p_HM=0.5
    offset <- 0

    if(version==1) pars <- c("L_M"=L_M,"L_H"=L,"D_EM"=D_EM,"D_EH"=D_EH,"D_IH"=D_IH,"b"=b,"p_HM"=p_HM,"p_MH"=p_MH,"constSeed"=offset)
    else pars <- c("L_M"=L_M,"D_EM"=D_EM,"L_H"=L,"D_C"=D_C,"D_F"=D_F,"D_EH"=D_EH,"D_IH"=D_IH,"b"=b,"p_HM"=p_HM,"p_MH"=p_MH,"constSeed"=offset)
    return(pars)
}

#' Default simulation parameters
#'
#' Generates the default vector of parameters for the simulation. Can specify which version of the model to use. Passing 1 gives the simple model with no age classes, 2 gives the parameters for the model with age classes. 3 gives the parameters for the age class model with parameters for head circumference distributions.
#' @return vector of names parameter values
#' @export
#' @seealso \code{\link{setupParsODE}}
#' @useDynLib zikaProj
setupParsLong <- function(version = 1){
    pars <- setupParsODE(version)
    sampFreq <- 7
    sampPropn <- 0.9
    mu_I <- 28
    sd_I <- 2
    mu_N <- 35
    sd_N <- 2
    probMicro <- 1
    baseline <- 0.00002
    burnin <- 3
    epiStart <- 5
    shape <- 12
    rate <- 10
    scale <- 1
    tstep <- 7
    if(version==1) pars <- c("baselineProb"=baseline,"burnin"=burnin,"epiStart"=epiStart,pars,"mean"=shape,"var"=rate,"scale"=scale, "tstep"=tstep)
    else if(version==2) pars <- c("probMicro"=probMicro,"baselineProb"=baseline,"burnin"=burnin,"epiStart"=epiStart,pars,"mean"=shape,"var"=rate,"scale"=scale,"tstep"=tstep)
    else pars <- c("sampFreq"=sampFreq,"sampPropn"=sampPropn,"mu_I"=mu_I,"sd_I"=sd_I,"mu_N"=mu_N,"sd_N"=sd_N,"probMicro"=probMicro,"baselineProb"=baseline,"burnin"=burnin,"epiStart"=epiStart,pars,"mean"=shape,"var"=rate,"scale"=scale,"tstep"=tstep)
    return(pars)   
}

#' Default parameter list setup
#'
#' Sets up the default list of parameters and initial conditions to be used by \code{\link{zika.sim}}. Can specify which version of the model to use. Passing 1 gives the simple model with no age classes, otherwise gives the parameters for the model with age classes.
#' @param duration Duration in years of the simulation. Defaults to 10 years
#' @return list of times, initial conditions, and ODE parameters
#' @export
#' @seealso \code{\link{setupParsLong}}
#' @useDynLib zikaProj
setupListPars <- function(duration=2*365, N_H = 1000000,N_M = 3*N_H, version=1){
    pars <- setupParsLong(version)
    D_C <- unname(pars["D_C"])
    L <- unname(pars["L_H"])
    S_M = 1*(N_M)
    E_M = 0
    I_M = 0

    S_H = N_H - 10
    E_H = 0
    I_H = 10
    R_H = 0
    
    S_F = 0.001*N_H
    S_C = D_C*N_H/(L+D_C)
    S_A = (1-0.001-D_C/(L+D_C))*N_H - 10
    E_C = 0
    E_A = 0
    E_F = 0
    I_C = 0
    I_A = 10
    I_F = 0
    R_C = 0
    R_A = 0
    R_F = 0
    
    if(version==1) y0 <- c("S_M" = S_M, "E_M"=E_M,"I_M"=I_M, "S_H"=S_H, "E_H"=E_H,"I_H"=I_H,"R_H"=R_H)
    else y0 <- c("S_M"=S_M, "E_M"=E_M,"I_M"=I_M,"S_C"=S_C,"S_A"=S_A,"S_F"=S_F,"E_C"=E_C,"E_A"=E_A,"E_F"=E_F,"I_C"=I_C,"I_A"=I_A,"I_F"=I_F,"R_C"=R_C,"R_A"=R_A,"R_F"=R_F)
    ts <- c("dur"=duration,"step"=1)
    
    return(list(ts,y0,pars))
}





#' Obsolete - the R implementation of the ODE model
#'
#' Set of ODEs for the zika SEIR model to be used by deSolve
#' @param t the vector of times to be solved over
#' @param y the compartment states
#' @param pars the parameters used to solve the ODE model
#' @return set of derivatives at the given time point
#' @export
#' @useDynLib zikaProj
zika.ode <-function(t, y,pars){
  L_M <- pars[1]
  D_EM <- pars[2]
   
  L_H <- pars[3]
  D_C <- pars[4]
  D_F <- pars[5]
  D_EH <- pars[6]
  D_IH <- pars[7]
  B_H <- L_H - D_C
 
  b <- pars[8]
  P_HM <- pars[9]
  P_MH <- pars[10]
  
  t_seed <- pars[11]
  I0 <- pars[12]
  epsilon <- 0.0001
  seed <- 0
  offset <- 0
  
  if(t >= t_seed){
      offset <- pars[13]
      if(t < t_seed + epsilon){
          seed <- I0
      }
  }
  
  S_M <- y[1]
  E_M <- y[2]
  I_M <- y[3]
  S_C <- y[4]
  S_A <- y[5]
  S_F <- y[6]
  
  R_C <- y[13]
  R_A <- y[14]
  R_F <- y[15]
  
  N_H <- sum(y[4:15])
  N_M <- sum(y[1:3])
  
  lambda_M <- b*(N_M/N_H)*P_HM*(I_C + I_A + I_F + offset + seed)/N_H
  lambda_H <- b*(N_M/N_H)*P_MH*I_M/N_H
  
  dS_M <- N_M/L_M - S_M/L_M - lambda_M*S_M
  dE_M <- lambda_M*S_M - E_M/L_M - E_M/D_EM
  dI_M <- E_M/D_EM - I_M/L_M
  
  dS_C <- N_H/L_H - S_C/L_H - S_C/D_C - lambda_H*S_C
  dS_A <- S_C/D_C - S_A/L_H - S_A/B_H + S_F/D_F - lambda_H*S_A
  dS_F <- S_A/B_H - S_F/D_F - S_F/L_H - lambda_H*S_F
  
  dE_C <- lambda_H*S_C - E_C/L_H           - E_C/D_EH           - E_C/D_C
  dE_A <- lambda_H*S_A - E_A/L_H - E_A/B_H - E_A/D_EH + E_F/D_F + E_C/D_C
  dE_F <- lambda_H*S_F - E_F/L_H + E_A/B_H - E_F/D_EH - E_F/D_F
  
  dI_C <- E_C/D_EH - I_C/L_H - I_C/D_IH           - I_C/D_C
  dI_A <- E_A/D_EH - I_A/L_H - I_A/D_IH - I_A/B_H + I_C/D_C + I_F/D_F
  dI_F <- E_F/D_EH - I_F/L_H - I_F/D_IH + I_A/B_H           - I_F/D_F 
  
  dR_C <- I_C/D_IH - R_C/L_H - R_C/D_C
  dR_A <- I_A/D_IH + R_C/D_C - R_A/L_H - R_A/B_H + R_F/D_F
  dR_F <- I_F/D_IH + R_A/B_H - R_F/D_F - R_F/L_H
  
  dIf_A <- I_F/D_F
  df_B <- S_F/D_F + E_F/D_F + R_F/D_F + I_F/D_F
  dE <- E_C/D_EH + E_A/D_EH + E_F/D_EH
  
  return(list(c(dS_M,dE_M,dI_M,dS_C,dS_A,dS_F,dE_C,dE_A,dE_F,dI_C,dI_A,dI_F,dR_C,dR_A,dR_F,dIf_A,df_B,dE)))
}


test_SEIR <- function(t,y,pars){
    L_M <- pars[1]
    D_EM <- pars[2]
    
    L_H <- pars[3]
    D_C <- pars[4]
    D_F <- pars[5]
    D_EH <- pars[6]
    D_IH <- pars[7]
    B_H <- L_H - D_C
    
    b <- pars[8]
    P_HM <- pars[9]
    P_MH <- pars[10]
    
    t_seed <- pars[11]
    I0 <- pars[12]

    S_M <- y[1]
    E_M <- y[2]
    I_M <- y[3]
    S_H <- y[4]
    E_H <- y[5]
    I_H <- y[6]
    R_H <- y[7]

    N_H <- S_H + E_H + I_H + R_H
    N_M <- S_M + E_M + I_M

    lambda_M <- b*P_HM*(I_H)/N_H
    lambda_H <- b*P_MH*I_M/N_H

    dS_M <- -lambda_M*S_M - S_M/L_M + N_M/L_M
    dE_M <- lambda_M*S_M - E_M/D_EM - E_M/L_M
    dI_M <- E_M/D_EM - I_M/L_M

    dS_H <- -lambda_H*S_H - S_H/L_H
    dE_H <- lambda_H*S_H  - E_H/D_EH - E_H/L_H
    dI_H <- E_H/D_EH - I_H/D_IH - I_H/L_H
    dR_H <- I_H/D_IH - R_H/L_H

    dDeaths <- S_M/L_M + E_M/L_M +  I_M/L_M
    dBirths <- N_M/L_M
    return(list(c(dS_M, dE_M,dI_M,dS_H,dE_H,dI_H,dR_H,dDeaths,dBirths)))
    
}
